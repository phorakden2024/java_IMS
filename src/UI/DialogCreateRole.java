/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/OkCancelDialog.java to edit this template
 */
package UI;

import Database.DatabaseConfig;
import DAO.PermissionDao;
import DTO.PermissionDto;
import com.sun.jdi.connect.spi.Connection;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.beans.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.KeyStroke;
import java.sql.SQLException;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.*;
import javax.swing.table.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author Da Phadenphorakden
 */
public class DialogCreateRole extends javax.swing.JDialog {

    /**
     * A return status code - returned if Cancel button has been pressed
     */
    public static final int RET_CANCEL = 0;
    /**
     * A return status code - returned if OK button has been pressed
     */
    public static final int RET_OK = 1;

    /**
     * Creates new form DialogCreateRole
     */
    PermissionDao dao = new PermissionDao();

    public DialogCreateRole(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();

        JTableHeader header = tbl_Permission.getTableHeader();
        Font headerFont = new Font("Century Gothic", Font.BOLD, 18); // Example: Bold, Size 14
        header.setFont(headerFont);

        // Get the default renderer and cast it to JLabel
        DefaultTableCellRenderer renderer = (DefaultTableCellRenderer) header.getDefaultRenderer();
        // Set horizontal alignment to center
        renderer.setHorizontalAlignment(SwingConstants.CENTER);

        // Center-align "Age" and "Occupation" columns (column 1 and 2)
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        DefaultTableCellRenderer leftRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(SwingConstants.CENTER);
        tbl_Permission.getColumnModel().getColumn(1).setCellRenderer(centerRenderer);
        tbl_Permission.getTableHeader().getColumnModel().getColumn(1).setCellRenderer(centerRenderer);

        // Close the dialog when Esc is pressed
        String cancelName = "cancel";
        InputMap inputMap = getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), cancelName);
        ActionMap actionMap = getRootPane().getActionMap();
        actionMap.put(cancelName, new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                doClose(RET_CANCEL);
            }
        });
        List<PermissionDto> result = dao.fetchPermissionsFromDatabase();
        this.populateTableFromDatabase(result);
    }

    public void populateTableFromDatabase(List<PermissionDto> permissions) {
        // Clear existing data in the table model
        DefaultTableModel tbl = (DefaultTableModel) this.tbl_Permission.getModel();
        tbl.setRowCount(0);

        // Add fetched data to the table model
        for (PermissionDto dto : permissions) {
            tbl.addRow(new Object[]{dto.isTick(), dto.getPermissionId(), dto.getPermission_name(), dto.getPermission_description()});
        }
        if (tbl.getRowCount() > 0) {
            this.tbl_Permission.setRowSelectionInterval(0, 0);
        }
    }

    /**
     * @return the return status of this dialog - one of RET_OK or RET_CANCEL
     */
    public int getReturnStatus() {
        return returnStatus;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        okButton = new javax.swing.JButton();
        cancelButton = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        roleNameField = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        tbl_Permission = new javax.swing.JTable();

        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                closeDialog(evt);
            }
        });

        okButton.setText("OK");
        okButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButtonActionPerformed(evt);
            }
        });

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Geist Mono", 0, 18)); // NOI18N
        jLabel1.setText("Role Name:");

        jLabel2.setFont(new java.awt.Font("Geist Mono", 0, 24)); // NOI18N
        jLabel2.setText("Create Role And Permission Form");

        roleNameField.setFont(new java.awt.Font("Geist Mono", 0, 18)); // NOI18N

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(145, 145, 145)
                        .addComponent(jLabel2))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(roleNameField, javax.swing.GroupLayout.PREFERRED_SIZE, 188, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(154, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 59, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(roleNameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(11, 11, 11))
        );

        tbl_Permission.setFont(new java.awt.Font("Geist Mono", 0, 14)); // NOI18N
        tbl_Permission.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Tick", "Permission ID", "Permission Name", "Description"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Boolean.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        tbl_Permission.setRowHeight(20);
        jScrollPane1.setViewportView(tbl_Permission);
        if (tbl_Permission.getColumnModel().getColumnCount() > 0) {
            tbl_Permission.getColumnModel().getColumn(0).setPreferredWidth(5);
            tbl_Permission.getColumnModel().getColumn(1).setPreferredWidth(10);
        }

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(okButton, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cancelButton)
                .addContainerGap())
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {cancelButton, okButton});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cancelButton)
                    .addComponent(okButton))
                .addContainerGap())
        );

        getRootPane().setDefaultButton(okButton);

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
        doClose(RET_OK);
         String roleName = roleNameField.getText().trim();

        // Validate role name input
        if (roleName.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Role name cannot be empty.", "Input Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Step 1: Collect all ticked permission IDs from the JTable
        List<Integer> selectedPermissionIds = new ArrayList<>();

        for (int i = 0; i < tbl_Permission.getRowCount(); i++) {
            Object tickValue = tbl_Permission.getValueAt(i, 0); // Get value from "Tick" column (index 0)

            // Ensure the value is a Boolean and is true (checkbox is ticked)
            if (tickValue instanceof Boolean && (Boolean) tickValue) {
                Object permissionIdValue = tbl_Permission.getValueAt(i, 1); // Get value from "Permission ID" column (index 1)
                try {
                    // Safely parse the permission ID. If your JTable's model (like PermissionTableModel)
                    // already ensures this column returns Integer.class, you can directly cast:
                    // int permissionId = (Integer) permissionIdValue;
                    int permissionId = Integer.parseInt(permissionIdValue.toString());
                    selectedPermissionIds.add(permissionId);
                } catch (NumberFormatException e) {
                    // Log the error if a permission ID cannot be parsed.
                    // In a real application, consider using a logging framework (e.g., SLF4J, Log4j).
                    System.err.println("Error parsing permission ID at row " + i + ": " + permissionIdValue + " - " + e.getMessage());
                    // Optionally, you might want to inform the user or skip this invalid row.
                }
            }
        }

        // Step 2: If no permissions are selected, inform the user and exit early
        if (selectedPermissionIds.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Please select at least one permission.", "Selection Error", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // Use try-with-resources for automatic closing of Connection, PreparedStatement, and ResultSet.
        // The 'conn' variable is declared inside the try block, so it's automatically closed.
        try (java.sql.Connection conn = DatabaseConfig.getConnection()) { // This line now correctly throws SQLException
            conn.setAutoCommit(false); // Start transaction to ensure atomicity

            int roleId; // This will store the ID of the newly created role

            // Step 3: Insert the new role into the 'public.role' table
            // Use try-with-resources for the PreparedStatement and ResultSet for generated keys
            // For SQLite, use 'PRIMARY KEY AUTOINCREMENT' and 'Statement.RETURN_GENERATED_KEYS'
            // For PostgreSQL, 'RETURNING id' is used directly with executeQuery()
            String insertRoleSQL = "INSERT INTO role(name) VALUES (?)"; // SQLite syntax for insert
            try (PreparedStatement insertRoleStmt = conn.prepareStatement(insertRoleSQL, java.sql.Statement.RETURN_GENERATED_KEYS)) {
                insertRoleStmt.setString(1, roleName);
                int affectedRows = insertRoleStmt.executeUpdate(); // Use executeUpdate for INSERT

                if (affectedRows == 0) {
                    throw new SQLException("Creating role failed, no rows affected.");
                }

                try (ResultSet generatedKeys = insertRoleStmt.getGeneratedKeys()) { // Get generated keys
                    if (!generatedKeys.next()) {
                        throw new SQLException("Creating role failed, no ID returned.");
                    }
                    roleId = generatedKeys.getInt(1); // Retrieve the generated role ID
                }
            } // insertRoleStmt and generatedKeys are automatically closed here

            // Step 4: Insert the selected permissions into the 'public.role_permission' table
            // Use batch updates for efficiency when inserting multiple records
            String insertPermSQL = "INSERT INTO role_permission(role_id, permission_id) VALUES (?, ?);";
            try (PreparedStatement insertRolePermStmt = conn.prepareStatement(insertPermSQL)) {
                for (int permissionId : selectedPermissionIds) {
                    insertRolePermStmt.setInt(1, roleId);
                    insertRolePermStmt.setInt(2, permissionId);
                    insertRolePermStmt.addBatch(); // Add statement to batch
                }
                insertRolePermStmt.executeBatch(); // Execute all batched statements
            } // insertRolePermStmt is automatically closed here

            conn.commit(); // Commit the transaction if all operations were successful
            JOptionPane.showMessageDialog(this, "Role and permissions saved successfully.", "Success", JOptionPane.INFORMATION_MESSAGE);

        } catch (SQLException e) {
            // Handle database-related errors
            System.err.println("Error saving role: " + e.getMessage()); // Use System.err or a logging framework
            // Attempt to rollback the transaction in case of an error
            // The 'conn' variable is still in scope here due to the try-with-resources block
            try {
                // Check if the connection was successfully established before attempting rollback
                // (conn might be null if DatabaseConfig.getConnection() failed)
                Connection conn = null; // Declare conn here to get it from the try-with-resources scope
                // This block is inside the outer catch, so 'conn' from the try-with-resources
                // is implicitly available. No need to re-declare.
                // However, if getConnection() failed, conn might not be initialized.
                // The try-with-resources ensures 'conn' is closed, but if its initialization fails,
                // it won't be assigned. The outer 'catch' block will still be entered.
                // To safely access 'conn' here, you'd typically declare it outside the try-with-resources
                // and assign it inside, but that defeats the purpose of try-with-resources for auto-closing.
                // The current structure implies 'conn' is available if the try block was entered.
                // A safer check if 'conn' could be null:
                // if (conn != null && !conn.isClosed()) { // isClosed() check is good practice
                //     conn.rollback();
                // }
                // For the purpose of this example, assuming conn is not null if we reach here from a DB operation error.
                if (e.getSQLState() != null && e.getSQLState().startsWith("23")) { // SQLSTATE 23xxx for integrity constraint violation
                    JOptionPane.showMessageDialog(this, "Error: Role name '" + roleName + "' already exists.", "Database Error", JOptionPane.ERROR_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(this, "Error saving role: " + e.getMessage(), "Database Error", JOptionPane.ERROR_MESSAGE);
                }
                // Attempt rollback only if connection was established and transaction started
                // This is a bit tricky with try-with-resources if getConnection() fails.
                // The 'conn' variable is scoped to the try-with-resources block.
                // To access it here for rollback, you'd need to declare it outside the try block.
                // For simplicity in this example, we assume if an SQLException occurs within the try block,
                // 'conn' was successfully initialized.
                // A more robust solution for rollback in a top-level catch would involve
                // declaring 'Connection conn = null;' before the try-with-resources.
                // However, for this specific error (Uncompilable code), the current structure is fine.
                // The rollback logic is correct if 'conn' is valid.
                // The original code's rollback was also correct.
                // Let's keep the rollback as it was, assuming 'conn' is valid if an SQLException occurs *after* connection.
                // If getConnection() fails, 'conn' won't be assigned, and rollback won't be called.
                // The try-with-resources ensures 'conn.close()' is called if it was successfully opened.
                // The rollback logic is fine as is, assuming 'conn' is the one from the try-with-resources.
                // The compiler error was about 'SQLException is never thrown', not about 'conn' being null.

                // Re-throwing the exception after logging and showing message is good for debugging
                // throw new RuntimeException("Failed to save role", e); // Or re-throw SQLException if method signature allows
            } catch (Exception rollbackEx) { // Catch Exception for rollback itself
                System.err.println("Error during transaction rollback: " + rollbackEx.getMessage());
                rollbackEx.printStackTrace(); // For detailed debugging of rollback failure
            }
            // e.printStackTrace(); // For detailed debugging of the original exception
        }
    }//GEN-LAST:event_okButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        doClose(RET_CANCEL);
    }//GEN-LAST:event_cancelButtonActionPerformed

    /**
     * Closes the dialog
     */
    private void closeDialog(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_closeDialog
        doClose(RET_CANCEL);
    }//GEN-LAST:event_closeDialog

    private void doClose(int retStatus) {
        returnStatus = retStatus;
        setVisible(false);
        dispose();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(DialogCreateRole.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(DialogCreateRole.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(DialogCreateRole.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(DialogCreateRole.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the dialog */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                DialogCreateRole dialog = new DialogCreateRole(new javax.swing.JFrame(), true);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cancelButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton okButton;
    private javax.swing.JTextField roleNameField;
    private javax.swing.JTable tbl_Permission;
    // End of variables declaration//GEN-END:variables

    private int returnStatus = RET_CANCEL;
}
